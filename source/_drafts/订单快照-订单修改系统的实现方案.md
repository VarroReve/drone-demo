---
title: 订单快照、订单修改系统的实现方案
date: 2019-09-11 10:17:38
tags: 
---

## 订单快照

#### 生成快照

在订单支付后、异步通知成功时，分发一个创建订单快照的任务到队列，已备后用。

#### 存储快照

将订单通过序列化方法转为 JSON，存储在 MySQL 数据库中的一个 json/text 字段中

（更通常的做法是存储在文档型数据库中，比如 MongoDB）。

## 订单对比、修改的主要实现方式

按照项目中现有的做法，要对比、修改订单时，先将 `oo_orders_products_modified` 表中的 JSON 数据取出来，然后转成数组，对数组操作一顿后再转回 JSON，最后存回数据库。

这么做有些问题：

1. 操作繁琐，需要反复地 `json_decode()`、`json_encode()`
2. 容错率低，对订单修改相关的数据操作时需要写大量判断和兼容性代码
3. 拓展性低，比如想要记录每一次的修改时，就难以实现

现在介绍一种更先进的实现方式：JSON Patch。

### JSON Patch

从字面意思来看，[JSON Patch](http://jsonpatch.com/) 就是给 JSON 文档打「补丁」，这个「补丁」就是这个「文档」需要修改的内容。

比如说现在有一个「文档」：

```json
{
  "order_id": "123456",
  "address": "Chong Qing Yu Bei",
  "amount": "50.00",
  "pay_method": "paypal"
}
```

然后有一个「补丁」：

```json
[
  { "op": "replace", "path": "/address", "value": "Bei Jing" },
  { "op": "add", "path": "/tags", "value": ["first-free", "risk-order"] },
  { "op": "remove", "path": "/pay_method" }
]
```

把「补丁」打在「文档」上，最终「文档」的内容变成了：

```json
{
  "order_id": "123456",
  "address": "Bei Jing",
  "amount": "50.00",
  "tags": ["first-free", "risk-order"]
}
```

可以看出「补丁」的内容就是一些增、删、改操作，如果把「文档」比作数据库中的一张表，那么「补丁」就是 SQL 语句。

### 订单补丁

有了「订单快照」，也就会有「订单补丁」，或者叫「订单修改记录」。订单补丁的意义在于可以把对订单的每一次修改都记录下来，并且可以进行更直观的对比。

以上面那个订单快照举例：

Admin A 想将该订单订单收货地址修改为 `Bei Jing`，那么首先修改订单的原始属性，再将该操作的 JSON Patch `[{ "op": "replace", "path": "/address", "value": "Bei Jing" }]` 存到数据库中，但不修改订单快照本身。

Admin B 想将该订单打上些标签，那么首先修改订单的原始属性，再将该操作的 JSON Patch `[{ "op": "add", "path": "/tags", "value": ["first-free", "risk-order"] }]` 存到数据库中，但不修改订单快照本身。

有了这些订单补丁，及订单原始属性快照，就可以绘制出这个订单的修改历程图，哪个管理员在哪个时间修改了订单的哪个属性，每一次修改前后订单发生了什么变化，都可以清晰得展示出来。这个和 Git 的提交历史树的概念很相似。

## 涉及到的项目和功能及预计工时

### API

- 订单快照字段设计（1.5 天）
- 实现订单快照、补丁系统基础（1 天）
- 修改「订单列表、详情接口」（0.5 天）
- 发送订单到 ERP（1 天）

### Service

- 重写「修改产品」功能（1 天）
- 重写「修改镜片」功能（1 天）
- 重写「修改镜架」功能（1 天）
- 重写「修改处方」功能（1 天）
- 重写「修改中文解析」功能（1 天）
- 重写「修改产品数量」功能（1 天）
- 重写「订单对比」功能（2 天）
- 重写「发送订单到 ERP」功能（1 天）
- 重写「订单详情页的数据展示」（1 天）

### 预计工时

14 ± 2 天